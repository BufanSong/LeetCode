HW7 Disjiont Set
Date: June 19 2019
Bufan Song
---------------------------------------------------------------------------------------------------------------------------------------------
Initial Disjiont Set:
UNION-FIND Class:

public class UnionFind{

	// The number of elements in the union find
	private int size;

	// Used to track the size of each of component 
	private int[] sz;

	// id[i] points to the parent of i, if id[i] = i then i is the root node
	private int[] id;

	// Tracks the number of components in the union find
	private int numComponents;

	public UnionFind(int size) {

		if (size <= 0) throw new IllegalArgumentException("Size <= 0 is not allowed");

		this.size = numComponents = size;
		sz = new int [size];
		id = new int[size];

		for (int i = 0; i < size; i++){
			id[i] = i; // Link to itself (self-root)
			sz[i] = 1; // Each component is default as the size of one
		}
	}

	// Find which component/set 'p' belongs to
	public int find(int p) {

		// Find the root of the component/set
		int root = p;
		while (root != id[root]){
			root = id[root];
		}

		// Compress the path leading back to root
		// Called "Path Compressionn"
		// which give us amortized time complexity
		while (p != root){
			int next = id[p];
			id[p] = root;
			p = next;
		}

		return root;
	}

	// Return whether or not the element 'p'
	// and 'q' are in the same componets/set
	public boolean connected (int p, int q) {
		return find(p) == find(q);
	}

	// Return the size of the components/set 'p' belongs to
	public int componentSize(int p){
		return sz[find[p]];
	}

	// Return the number of elements in this UnionFind Set
	public int size() {
		return size;
	}

	// Return the number of remaining components/sets
	public int components() {
		return numComponents;
	}

	// Unify the components/ sets containing elements 'p' and 'q'
	public void unify (int p, int q){

		int root1 = find(p);
		int root2 = find(q);

		// These elements are in the same group
		if (root1 == root2) return;

		// Merge smaller size component into larger one
		if (sz[root1] < sz[root2]){
			sz[root2] += sz[root1];
			id[root1] = root2;
		}else{
			sz[root1] += sz[root2];
			id[root2] = root1;
		}
		// If unified, then the number of components must be decreased by one
		numComponents--;
		
	}
}
---------------------------------------------------------------------------------------------------------------------------------------------


Q1: 
305. Number of Islands II
A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example:
Input: m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]]
Output: [1,1,2,3]
---------------------------------------------------------------------------------------------------------------------------------------------
Sol:
class Solution {
    
    public class UnionFind{

        // The number of elements in the union find
        private int size;

        // Used to track the size of each of component 
        private int[] sz;

        // id[i] points to the parent of i, if id[i] = i then i is the root node
        private int[] id;

        // Tracks the number of components in the union find
        private int numComponents;

        public UnionFind(int size) {

            if (size <= 0) throw new IllegalArgumentException("Size <= 0 is not allowed");

            this.size = numComponents = size;
            sz = new int [size];
            id = new int[size];

            for (int i = 0; i < size; i++){
                id[i] = -1; 
                sz[i] = 1; // Each component is default as the size of one
            }
        }

        // Find which component/set 'p' belongs to
        public int find(int p) {

            // Find the root of the component/set
            int root = p;
            while (root != id[root]){
                root = id[root];
            }

            // Compress the path leading back to root
            // Called "Path Compressionn"
            // which give us amortized time complexity
            while (p != root){
                int next = id[p];
                id[p] = root;
                p = next;
            }

            return root;
        }

        // Return whether or not the element 'p'
        // and 'q' are in the same componets/set
        public boolean connected (int p, int q) {
            return find(p) == find(q);
        }

        // Return the size of the components/set 'p' belongs to
        // public int componentSize(int p){
        //     return sz[find[p]];
        // }

        // Return the number of elements in this UnionFind Set
        public int size() {
            return size;
        }

        // Return the number of remaining components/sets
        public int components() {
            return numComponents;
        }

        // Unify the components/ sets containing elements 'p' and 'q'
        public boolean unify (int p, int q){

            int root1 = find(p);
            int root2 = find(q);

            // These elements are in the same group
            if (root1 == root2) return false;

            // Merge smaller size component into larger one
            if (sz[root1] < sz[root2]){
                sz[root2] += sz[root1];
                id[root1] = root2;
            }else{
                sz[root1] += sz[root2];
                id[root2] = root1;
            }
            // If unified, then the number of components must be decreased by one
            numComponents--;
            return true;

        }
    }
    public List<Integer> numIslands2(int m, int n, int[][] positions) {
        List<Integer> res = new ArrayList<>();
        if (m == 0 || n == 0 || positions == null || positions.length == 0 ||
           positions[0].length == 0)
            return res;
        int count = 0;
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        UnionFind uf = new UnionFind(m * n);
        for (int[] position : positions){
            int x = position[0];
            int y = position[1];
            int p = x * n + y;
            if(uf.id[p] != -1){ // duplicate position
                res.add(count);
                continue;
            }
            uf.id[p] = p;
            count++;
            for (int[] dir : dirs) {
                int r = x + dir[0];
                int c = y + dir[1];
                if (isValid(uf, m, n, r, c)) {
                    int q = r * n + c;
                    if (uf.unify ( p, q)){
                        count--;
                    }
                }
            }
            res.add(count);
        }
        return res;
    }
    private boolean isValid(UnionFind uf, int m, int n, int r, int c){
        if (r < 0 || r >= m || c < 0 || c >= n || uf.id[r * n + c] == -1){
            return false;
        }
        return true;
    }
}
---------------------------------------------------------------------------------------------------------------------------------------
Q2:
684. Redundant Connection
Links: https://leetcode.com/problems/redundant-connection/
In this problem, a tree is an undirected graph that is connected and has no cycles.
The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.
The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u < v, that represents an undirected edge connecting nodes u and v.
Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u < v.

Example 1:
Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3
---------------------------------------------------------------------------------------------------------------------------------------------
Solï¼š
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        UnionFind uf = new UnionFind (edges.length);
        for (int[] edge : edges){
            if (!uf.union( edge[0] - 1, edge[1] - 1))
                return edge;
        }
        throw new AssertionError();
    }
}

class UnionFind{
    int[] id;
    int[] sz;
    
    public UnionFind (int size) {
        id = new int [size];
        sz = new int [size];
        for (int i = 0; i < size; i++){
            id[i] = i;
            sz[i] = 1;
        }
    }
    public int find (int p){
        int root = p;
        while (id[root] != root){
            root = id[root];
        }
        
        while (p != root){
            int next = id[p];
            id[p] = root;
            p = next;
        }
        return root;
    }
    public boolean union (int p, int q) {
        int rootp = find(p);
        int rootq = find(q);
        if (rootp == rootq)
            return false;
        if (sz[rootp] >= sz[rootq]){
            id[rootq] = rootp;
            sz[rootp] += sz[rootq]; 
        }else{
            id[rootp] = rootq;
            sz[rootq] += sz[rootp];
        }
        return true;
    }
}
