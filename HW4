HW4. TRIE
Date: June 10 2019
Arthor: Bufan Song
-------------------------------------------------------------------------------------------------------------------------------
Q1:
-------------------------------------------------------------------------------------------------------------------------------
208. Implement Trie(Prefix Tree)
Implement a trie with insert, search, and startsWith methods.

Example:
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");   
trie.search("app");     // returns true
Note:
You may assume that all inputs are consist of lowercase letters a-z.
All inputs are guaranteed to be non-empty strings.
-------------------------------------------------------------------------------------------------------------------------------
Thoughts:
First build the structure of TrieNode. For this case, lowercase letters a-z, so the range R = 26. For each TrieNode links,
create an array of TrieNode[R]. Basic function of TrieNode is TrieNode.containsKey(char); TrieNode.get(char); 
TrieNode.put(char, TrieNode);  TrieNode.isEnd(); TrieNode.setEnd();
After that, use TrieNode to get the function of insert, search and search(prefix).

-------------------------------------------------------------------------------------------------------------------------------
Sol:
class TrieNode{
    private TrieNode[] links;
    
    private final int R = 26;
    
    private boolean isEnd;
    
    public TrieNode(){
        links = new TrieNode[R];
    }
    
    public boolean containsKey(char ch){
        return links[ch - 'a'] != null;
    }
    
    public TrieNode get(char ch){
        return links[ch - 'a'];
    }
    
    public void put(char ch, TrieNode node){
        links[ch - 'a'] = node;
    }
    
    public void setEnd(){
        isEnd = true;
    }
    
    public boolean isEnd(){
        return isEnd;
    }
}

class Trie {
    /** Initialize your data structure here. */
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();    
    }
    
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++){
            char currentChar = word.charAt(i);
            if (!node.containsKey(currentChar)){
                node.put(currentChar, new TrieNode());
            }
            node = node.get(currentChar);
        }
        node.setEnd();
    }
    private TrieNode searchPrefix(String word){
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++){
            char curLetter = word.charAt(i);
            if (node.containsKey(curLetter)){
                node = node.get(curLetter);
            }
            else{
                return null;
            }
        }
        return node;
    }
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isEnd();
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode node = searchPrefix(prefix);
        return node != null;
    }
}

-------------------------------------------------------------------------------------------------------------------------------
Q2:
-------------------------------------------------------------------------------------------------------------------------------
211. Add and Search Word - Data structure design
Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

Example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
-------------------------------------------------------------------------------------------------------------------------------
Thoughts: Use TrieNode Class, defien TrieNode[] children = new TrieNode[26];Boolean isWordEnd; 
for '.', simply use a helper function of dfs, try every TrieNode at index k which is not nullã€‚ 
-------------------------------------------------------------------------------------------------------------------------------
Sol:
class WordDictionary {
    public class TrieNode{
        public TrieNode[] children = new TrieNode[26];
        public boolean isWordEnd;
    }
    private TrieNode root = new TrieNode();
    /** Initialize your data structure here. */
    public WordDictionary() {
        
    }
    
    /** Adds a word into the data structure. */
    public void addWord(String word) {
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++){
            char c = word.charAt(i);
            if (node.children[c - 'a'] == null){
                node.children[c - 'a'] = new TrieNode();
            }
            node = node.children[c - 'a'];
        }
        node.isWordEnd = true;
    }
    
    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
    public boolean search(String word) {
        return helper(word, 0, root);
    }
    public boolean helper(String word, int k, TrieNode node){
        if (k == word.length()){
            return node.isWordEnd;
        }
        char c = word.charAt(k);
        if (c == '.'){
            for (int i = 0; i < node.children.length; i++){
                if (node.children[i] != null &&
                   helper(word, k+1, node.children[i]))
                    return true;
            }
        }else{
            return node.children[c - 'a'] != null && helper(word, k+1, node.children[c - 'a']);
        }
        return false;
    }
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
 
 -------------------------------------------------------------------------------------------------------------------------------
Q3:
-------------------------------------------------------------------------------------------------------------------------------
745. Prefix and Suffix Search
Given many words, words[i] has weight i.

Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.

Examples:
Input:
WordFilter(["apple"])
WordFilter.f("a", "e") // returns 0
WordFilter.f("b", "") // returns -1
-------------------------------------------------------------------------------------------------------------------------------
Thoughts:
Initial thoughts based on Hint1. Due to every word in words[], use a for loop to add every words' combination of suffix + '{'
+ 'prefix' into the TrieTree, and for the TrieNode class, adding one parameter called weight. So TrieNode.weight can be recorded. 
In the word for loop, for example(apple), we need to add(apple{apple; pple{apple; ple{apple; le{apple;e{apple; {apple). so 
when use f(String prefix, String suffix), just need to search the String (suffix + '{' + prefix) either present or not,
if not present, return -1, if reach the end of the string, need to return the TrieNode's weight as result. 
// Keep in mind that the TrieNode.children.length has to increase 1 from 26 to 27, due to presence of '{'. In Unicode, '{' is
right after a-z, so can be use as seperator between suffix and prefix in the new string. Or can use a character that right 
before a-z in Unicode. 
-------------------------------------------------------------------------------------------------------------------------------
Sol:
class TrieNode{
    public TrieNode[] children;
    int weight;
    public TrieNode(){
        children = new TrieNode[27];
        weight = 0;
    }
    //public boolean isWordEnd; 
}

class WordFilter { 
    
    TrieNode root = new TrieNode();
    
    public WordFilter(String[] words) {
        for (int weight = 0; weight < words.length; weight++){
            String word = words[weight] + '{';
            for (int i = 0; i < word.length(); i++){
                TrieNode cur = root;
                cur.weight = weight;
                for (int j = i; j < word.length() * 2 - 1; j++){
                    int k = j % word.length();
                    char c = word.charAt(k);
                    if (cur.children[c - 'a'] == null){
                        cur.children[c - 'a'] = new TrieNode();
                    }
                    cur = cur.children[c - 'a'];
                    cur.weight = weight;
                }
            }
        }
    }
    
    public int f(String prefix, String suffix) {
        TrieNode cur = root;
        for (char letter : (suffix + '{' + prefix).toCharArray()){
            if (cur.children[letter - 'a'] == null)
                return -1;
            cur = cur.children[letter - 'a'];
        }
        return cur.weight;
    }
}

/**
 * Your WordFilter object will be instantiated and called as such:
 * WordFilter obj = new WordFilter(words);
 * int param_1 = obj.f(prefix,suffix);
 */
