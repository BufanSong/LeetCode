HW8 Dynamic Programming
Date: June 20 2019
Bufan Song
-----------------------------------------------------------------------------------------------------------------------------
Q1: 
63. Unique Paths II
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
Now consider if some obstacles are added to the grids. How many unique paths would there be?
Example 1:
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
-----------------------------------------------------------------------------------------------------------------------------
Thoughts:
for the first row and first column, if there is no obstacle, then their largest possible path for that node is 1, if there is obstacle
then the current node and following nodes will be 0, which stands for 0 possible path. 
After setting the first col and row, then go through the map row by row, and first determine if this node is obstacle, if there is, 
which means obstacleGrid[i][j] == 1, then simply set it as = 0; If it is not, then the current node's possible path is depend on
the possible path of the node obstacleGrid[i-1][j] and obstacleGrid[i][j-1], which is left and up. 
After go through all the map, return the right bottom node, which stands for all the uniqle paths number. 
-----------------------------------------------------------------------------------------------------------------------------
Sol:
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int row = obstacleGrid.length;
        int col = obstacleGrid[0].length;
        
        if(obstacleGrid[0][0] == 1 || obstacleGrid[row-1][col-1] == 1)
            return 0; 
        
        obstacleGrid[0][0] = 1;
        // filling first row
        for (int i = 1; i < col; i++){
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i-1] == 1) ? 1 : 0;
        }
        // filling first column 
        for (int i = 1; i < row; i++){
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i-1][0] == 1) ? 1 : 0;
        }
        for (int i = 1; i < row; i++){
            for (int j = 1; j < col; j++){
                if (obstacleGrid[i][j] == 1)
                    obstacleGrid[i][j] = 0;
                else if (obstacleGrid[i][j] == 0){
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1];
                }
            }
        }
        return obstacleGrid[row-1][col-1];
    }
}
-----------------------------------------------------------------------------------------------------------------------------
Q2:
279. Perfect Squares
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:
Input: n = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
-----------------------------------------------------------------------------------------------------------------------------
Thoughts: Build an array dp[] with length n+1; Fill all the spots with Integer.MAX_VALUE, set dp[0] as 0. for loop the array
from 1 to n, while set an inner loop with variable j, j can be increased from 1 to j*j <= i. Need to find minimum dp[i], which 
is the minimum value of dp[i - j*j]+1; j*j represents perfect square number(1 = 1*1; 4 = 2*2; 9 = 3*3, etc) 
-----------------------------------------------------------------------------------------------------------------------------
Sol:
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n+1]; // create an array to store the dp res;
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= n; i++){
            for (int j = 1; j * j <= i; j++){
                dp[i] = Math.min(dp[i], dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
}
