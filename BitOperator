BitOperator Conclusion
-------------------------------------------------------------------------------------------------------------------------------
461. Hamming Distance
The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, calculate the Hamming distance.

Note:
0 ≤ x, y < 231.

Example:

Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
-------------------------------------------------------------------------------------------------------------------------------
Sol:
class Solution {
    public int hammingDistance(int x, int y) {
        int d = 0;
        int bitxor = x ^ y;
        while (bitxor > 0){
            d += bitxor % 2;
            bitxor = bitxor >> 1;
        }
        return d;
    }
}
-------------------------------------------------------------------------------------------------------------------------------
Thoughts:
By using the XOR operator to comparing two value in bitwise, if they not equal, then get a 1. Then count every bit from low to high,
if bitxor % 2 == 1, d++ and bitxor move to the right one bit. Return d. 

-------------------------------------------------------------------------------------------------------------------------------
268. Missing Number
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

Example 1:

Input: [3,0,1]
Output: 2
Example 2:

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
Note:
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
-------------------------------------------------------------------------------------------------------------------------------
Thought:
Run in linear runtime, then hashset, but not satisfy the constant extra space. Use bit operator XOR, cause the total array is 
only missing one number from 0 to n-1, so the n has to replace that missing number. Assume the missing number is n, and xor all
the number from 0 to n-1 with the indexed number nums[i], and the only left one is the missing number, others will be paired out. 
-------------------------------------------------------------------------------------------------------------------------------
Sol:
class Solution {
    public int missingNumber(int[] nums) {
        int missing = nums.length; 
        for (int i = 0; i < nums.length; i++) {
            missing ^= i ^ nums[i];
        }
        return missing;
    }
}
